Пошаговое описание
1. Построение дефолтного массива
defaultSteps ← DefaultAlgo(params_in)
2. Поиск максимального бида
MaxBid ← MaxSetBit(defaultSteps)
3. Критерий применимости нового алгоритма
Если критерий возвращает «нет», сразу возвращаем
resultSteps = defaultSteps
Иначе продолжаем
4. Определяем границы нового диапазона
a ← min(defaultSteps)    // левый край
b ← MaxBid               // правый край
5. Правило малого диапазона
Если отрезок слишком короткий, весь массив схлопывается в один элемент:
если (b − a) < Δ_param:
      resultSteps = [MaxBid]
      выход
5.5. 
Если MaxBid < min(defaultSteps):
resultSteps = min(defaultSteps)
6. Выбор исходной длины
Начинаем с той же длины, что у дефолтного массива:
N ← length(defaultSteps)
7. Корректировка длины под ограничение Δ_param
Пока разница между соседними точками меньше Δ_param, сокращаем количество промежуточных точек (т. е. уменьшаем N на 1).
пока (N > 2) и ((b − a)/(N − 1) < Δ_param):
      N ← N − 1
После цикла гарантируется, что при выбранной длине N равномерный шаг будет не меньше Δ_param.
8. Равномерное разрезание отрезка [a, b]
Теперь, когда длина N окончательно зафиксирована, строго нарезаем отрезок a…b на N − 1 равных куска:
Δ_final ← (b − a)/(N − 1)          // итоговый равномерный шаг
resultSteps[0]     = a
resultSteps[N−1]   = b
для i = 1 … N−2:
     resultSteps[i] = a + i·Δ_final
Здесь мы «ограничены параметром» N (установленным на шаге 7) и используем равномерную сетку: все промежутки равны Δ_final.
9. Возврат результата
return resultSteps